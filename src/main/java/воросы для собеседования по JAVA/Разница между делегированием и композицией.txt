Делегирование - это когда часть работы класс "перекладывает на" другие классы.
Например, начальник разработки, получив заказ на новую фичу, делегирует эту задачу одному из своих подчиненных.
Пример делегирования в программировании - когда класс, выполняющий сложный алгоритм логирует свои действия не самостоятельно (открывая файл и дописывая в него), а с помощью класса Logger, вызывая в нужных местах его методы.
Обычно делегированию противопоставляют реализацию чего-либо в том же классе. Например, если у вас есть класс-"всемогутор", то лучше разделить его на несколько классов, у каждого из которых будет своя зона ответственности. Основной класс будет лишь заниматься диспетчеризацией вызовов между этими классами.

Композиция - это когда между моделируемыми объектами явно прослеживается отношение "часть - целое" (has a).
Например, моделируя автомобиль, естественно считать, что двигатель - это часть автомобиля. Программируя эту модель, Вы выразите это в том, что объект класса Engine станет членом класса Auto.
Композиции обычно противопоставляют агрегацию и ассоциацию. Агрегация похожа на композицию в том, что это тоже отношение вида часть-целое, однако между объектами нет отношения владения. Например, "группа студентов" - студент часть группы, но студент может существовать и вне группы. То есть деструктор группы не должен "убивать" объектов-студентов. Ассоциация выражает любое отношение между объектами, которые могут вызывать методы друг друга.
То есть делегирование можно устроить имея как отношение ассоциации, так и отношение композиции между объектами.
Еще композиции противопоставляют наследование. Но в этом случае композиция и делегирование - синонимы. В случае с наследованием мы выносим общие методы в базовый класс Base, а различные реализации в классы-наследники Derived1, Derived2. Создавая экземпляр одного из Derived-классов, мы получаем необходимую функциональность объекта.
Но то же самое можно сделать и по-другому. В классе Base мы по-прежнему оставляем общие методы, и добавляем ссылку (указатель) (то есть аггрегируем указатель на реализацию) на интерфейс вспомогательных методов IRealization. Вспомогательные методы по-разному реализуются в классах Realization1, Realization2, которые наследуют* интерфейс IRealization. Теперь в зависимости от того, на объект какого из классов Realization будет указывать объект Base, мы будем получать разную функциональность. Base делегирует свои обязаности в IRealization.
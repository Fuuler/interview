Посмотрим же на методы, которые мы получаем по-умолчанию для своего класса:

wait(), notify(), notifyAll() - три метода из набора для многопоточности. Не уверен, что в этом курсе расскажу про это, так как -  это довольно обширная и сложная тема. Однако, даже по названиям можно понять, что эти методы способны заставить некоторых потом ждать (wait) и, наоборот - пробудить (notify).

getClass() - получить класс объекта во время выполнения. В основном используется для рефлексии.

clone() - получить точную копию объекта. Не рекомендуется использовать. Чаще советуют использовать конструктор копирования.

equals() - сравнивает два объекта.

hashcode() - числовое представление объекта. Значение по-умолчанию - целочисленный адрес в памяти.

toString() - возвращает представление объекта в виде строки. По-умолчанию возвращает имя_класса@hashcode в 16-ричной системе. Если hashcode не переопределен, то вернут значение по-умолчанию.

Иногда для коллекций (в следующей статье) требуется переопределить equals и hashcode.

Правила, которые следует учесть при переопределении equals:

Рефлексивность: x.equals(x) == true
Симметричность: если x.equals(y), тогда y.equals(x) == true
Переносимость: если x.equals(y) и y.equals(z), тогда x.equals(z) == true
Консистентность: если x.equals(y), тогда x.equals(y) == true
Null проверка: x.equals(null) == false
Отвечаю на вопрос - почему нужно переопределить hashcode? Дело в том, что значение по-умолчанию, как писалось выше, это адрес в памяти. То есть может случиться такая ситуация, что вы переопределили equals и объекты равным по этому equals, но они находятся на разных адресах памяти и это нарушает соглашение между equals и hashcode:

    Если объекты равны по equals - они должны быть равны и по hashcode. Если объекты не равны по equals, то их hashcode может быть равен, а может и нет.

Однако, равенство hashcode при неравенстве по equals - это коллизия и ее стоит избегать при помощи правильно переопределенного hashcode. В теме по коллекциям вы поймете почему.